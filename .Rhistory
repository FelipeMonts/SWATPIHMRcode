diff <- function(x,y)
{
return(x/y) #Try also x+y
}
TheLine <- function(x1,y1,slp,d)
{
z = slope*(d-x1)+y1
return(z)
}
x = seq(-20,20,0.5)
y = seq(-20,20,0.5)
f = c(-5,5)
h = c(-5,5)
plot(f,h,main="Slope field")
for(j in x)
{
for(k in y)
{
slope = diff(j,k)
domain = seq(j-0.07,j+0.07,0.14)
z = TheLine(j,k,slope,domain)
arrows(domain[1],z[1],domain[2],z[2],length=0.08)
}
}
require(grDevices) # for colours
filled.contour(volcano, color = terrain.colors, asp = 1) # simple
x <- 10*1:nrow(volcano)
y <- 10*1:ncol(volcano)
filled.contour(x, y, volcano, color = terrain.colors,
plot.title = title(main = "The Topography of Maunga Whau",
xlab = "Meters North", ylab = "Meters West"),
plot.axes = { axis(1, seq(100, 800, by = 100))
axis(2, seq(100, 600, by = 100)) },
key.title = title(main = "Height\n(meters)"),
key.axes = axis(4, seq(90, 190, by = 10)))  # maybe also asp = 1
mtext(paste("filled.contour(.) from", R.version.string),
side = 1, line = 4, adj = 1, cex = .66)
# Annotating a filled contour plot
a <- expand.grid(1:20, 1:20)
b <- matrix(a[,1] + a[,2], 20)
filled.contour(x = 1:20, y = 1:20, z = b,
plot.axes = { axis(1); axis(2); points(10, 10) })
## Persian Rug Art:
x <- y <- seq(-4*pi, 4*pi, len = 27)
r <- sqrt(outer(x^2, y^2, "+"))
filled.contour(cos(r^2)*exp(-r/(2*pi)), axes = FALSE)
## rather, the key *should* be labeled:
filled.contour(cos(r^2)*exp(-r/(2*pi)), frame.plot = FALSE,
plot.axes = {})
require(grDevices) # for colours
filled.contour(volcano, color = terrain.colors, asp = 1) # simple
x <- 10*1:nrow(volcano)
y <- 10*1:ncol(volcano)
filled.contour(x, y, volcano, color = terrain.colors,
plot.title = title(main = "The Topography of Maunga Whau",
xlab = "Meters North", ylab = "Meters West"),
plot.axes = { axis(1, seq(100, 800, by = 100))
axis(2, seq(100, 600, by = 100)) },
key.title = title(main = "Height\n(meters)"),
key.axes = axis(4, seq(90, 190, by = 10)))  # maybe also asp = 1
mtext(paste("filled.contour(.) from", R.version.string),
side = 1, line = 4, adj = 1, cex = .66)
# Annotating a filled contour plot
a <- expand.grid(1:20, 1:20)
b <- matrix(a[,1] + a[,2], 20)
filled.contour(x = 1:20, y = 1:20, z = b,
plot.axes = { axis(1); axis(2); points(10, 10) })
f <- function(x, y) x^2 - y^2
xx <- c(-1, 1); yy <- c(-1, 1)
## Not run:
vectorfield(f, xx, yy, scale = 0.1)
for (xs in seq(-1, 1, by = 0.25)) {
sol <- rk4(f, -1, 1, xs, 100)
lines(sol$x, sol$y, col="darkgreen")
}
grid()
## End(Not run)
library(oce)
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type='n')
drawDirectionField(x=rep(0, 2), y=rep(0, 2), u=c(1, 1), v=c(1, -1), scalex=0.5, add=TRUE)
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type='n')
drawDirectionField(x=rep(0, 2), y=rep(0, 2), u=c(1, 1), v=c(1, -1), scalex=0.5, add=TRUE,
type=2)
install.packages("oce")
library(oce)
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type='n')
drawDirectionField(x=rep(0, 2), y=rep(0, 2), u=c(1, 1), v=c(1, -1), scalex=0.5, add=TRUE)
plot(c(-1.5, 1.5), c(-1.5, 1.5), xlab="", ylab="", type='n')
drawDirectionField(x=rep(0, 2), y=rep(0, 2), u=c(1, 1), v=c(1, -1), scalex=0.5, add=TRUE,
type=2)
#############################################################################################################################
#
#  Program find the most abundant HRU in the SWAT input files, inside each PIHM mesh
#  to translate then the inputs of the HRUS into Cycles format for simulation
#
#
#  Felipe Montes,  2017/03/29
#
##############################################################################################################################
############################### Record Time To start##########################################################
TimeStart<-Sys.time()  ;
###############################################################################################################
#                          Loading Packages and setting up working directory
###############################################################################################################
#  Tell the program where the package libraries are  #####################
.libPaths("C:/Felipe/Sotware&Coding/R_Library/library")  ;
#  Set Working directory
setwd("C:/Felipe/PIHM-CYCLES/PIHM/PIHM_Felipe/CNS/WE-38/WE38_Files_PIHM_Cycles20170208/SWATPIHMRcode") ;
###############################################################################################################
#                         Call packages needed to process the data
#
###############################################################################################################
library("foreign") ;
library("dplyr");
###############################################################################################################
#                         Read the database of PIHM Mesh and Swat HRU intersection polygons and
#                        select the appropriate fields
###############################################################################################################
Int_HRU_Mesh<-read.dbf('../SwatPIHM/WE38MeshIntersectionHRUManhantango.dbf', as.is=T ) ;
head(Int_HRU_Mesh)
str(Int_HRU_Mesh)
names(Int_HRU_Mesh)
############### check if all the trinagles number sequence exist
Triangles.numbers.missing<-which(!c(1:883) %in% as.numeric(levels(as.factor(Int_HRU_Mesh$Ele_ID))))   ;
Triangles.numbers.missing
# ############# code to use one triangle to test results
# Triangle.no<-3
# OneTirangle<-Int_HRU_Mesh[Int_HRU_Mesh$Ele_ID==Triangle.no,] ;
#
# aggregate(formula=TriaHruAre~LU_CODE, data=OneTirangle, FUN=sum, simplify=T)
########### Make LU_CODE as a factor to differentiate between land Use types
Int_HRU_Mesh$LU_CODE<-as.factor(Int_HRU_Mesh$LU_CODE);
LU.Area.Mesh.count<-xtabs(formula=~Ele_ID+LU_CODE, data=Int_HRU_Mesh, sparse=F) ;
LU.Area.Mesh.count
LU.Area.Mesh.count<-xtabs(formula=~Ele_IDxLU_CODE, data=Int_HRU_Mesh, sparse=F) ; # using Xtabs produce a table or a sparse matrix
#############################################################################################################################
#
#  Program find the most abundant HRU in the SWAT input files, inside each PIHM mesh
#  to translate then the inputs of the HRUS into Cycles format for simulation
#
#
#  Felipe Montes,  2017/03/29
#
##############################################################################################################################
############################### Record Time To start##########################################################
TimeStart<-Sys.time()  ;
###############################################################################################################
#                          Loading Packages and setting up working directory
###############################################################################################################
#  Tell the program where the package libraries are  #####################
.libPaths("C:/Felipe/Sotware&Coding/R_Library/library")  ;
#  Set Working directory
setwd("C:/Felipe/PIHM-CYCLES/PIHM/PIHM_Felipe/CNS/WE-38/WE38_Files_PIHM_Cycles20170208/SWATPIHMRcode") ;
###############################################################################################################
#                         Call packages needed to process the data
#
###############################################################################################################
library("foreign") ;
library("dplyr");
###############################################################################################################
#                         Read the database of PIHM Mesh and Swat HRU intersection polygons and
#                        select the appropriate fields
###############################################################################################################
Int_HRU_Mesh<-read.dbf('../SwatPIHM/WE38MeshIntersectionHRUManhantango.dbf', as.is=T ) ;
head(Int_HRU_Mesh)
str(Int_HRU_Mesh)
names(Int_HRU_Mesh)
############### check if all the trinagles number sequence exist
Triangles.numbers.missing<-which(!c(1:883) %in% as.numeric(levels(as.factor(Int_HRU_Mesh$Ele_ID))))   ;
Tri
Triangles.numbers.missing
Int_HRU_Mesh$LU_CODE<-as.factor(Int_HRU_Mesh$LU_CODE);
LU.Area.Mesh.count<-xtabs(formula=~Ele_IDxLU_CODE, data=Int_HRU_Mesh, sparse=F) ; # using Xtabs produce a table or a sparse matrix
LU.Area.Mesh.count<-xtabs(formula=~Ele_ID*LU_CODE, data=Int_HRU_Mesh, sparse=F) ; # using Xtabs produce a table or a sparse matrix
LU.Area.Mesh.count<-xtabs(formula=~Ele_ID+LU_CODE, data=Int_HRU_Mesh, sparse=F) ; # using Xtabs produce a table or a sparse matrix
LU.Area.Mesh.count
LU.Area.Mesh.count<-aggregate(formula=TriaHruAre~LU_CODE+Ele_ID, data=Int_HRU_Mesh, FUN=length, simplify=T) ;
LU.Area.Mesh.count
LU.Area.Mesh.count<-aggregate(formula=TriaHruAre~Ele_ID+LU_CODE, data=Int_HRU_Mesh, FUN=length, simplify=T) ;
LU.Area.Mesh.sum<-aggregate(formula=TriaHruAre~Ele_ID+LU_CODE, data=Int_HRU_Mesh, FUN=sum, simplify=T) ;
head(LU.Area.Mesh)
str(LU.Area.Mesh)
Int_HRU_Mesh<-read.dbf('../SwatPIHM/WE38MeshIntersectionHRUManhantango.dbf', as.is=T ) ;
head(Int_HRU_Mesh)
str(Int_HRU_Mesh)
names(Int_HRU_Mesh)
Triangles.numbers.missing<-which(!c(1:883) %in% as.numeric(levels(as.factor(Int_HRU_Mesh$Ele_ID))))   ;
Triangles.numbers.missing
Int_HRU_Mesh$LU_CODE<-as.factor(Int_HRU_Mesh$LU_CODE);
head(LU.Area.Mesh.sum)
str(LU.Area.Mesh.sum)
LU.Area.Mesh.count
LU.Area.Mesh.count<-aggregate(formula=TriaHruAre~Ele_ID+LU_CODE, data=Int_HRU_Mesh, FUN=length, simplify=T) ;
LU.Area.Mesh.count
LU.Area.Mesh.sum<-aggregate(formula=TriaHruAre~Ele_ID+LU_CODE, data=Int_HRU_Mesh, FUN=sum, simplify=T) ;
head(LU.Area.Mesh.sum)
View(LU.Area.Mesh.count)
View(LU.Area.Mesh.count)
View(LU.Area.Mesh.sum)
View(LU.Area.Mesh.sum)
View(LU.Area.Mesh.count)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh, FUN = max, simplify=T);
str(LU.Area.Mesh.max)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh, FUN = max, simplify=T);
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = max, simplify=T);
str(LU.Area.Mesh.max)
head(LU.Area.Mesh.max)
view(LU.Area.Mesh.max)
View(LU.Area.Mesh.max)
View(LU.Area.Mesh.max)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = max, simplify=T);
str(LU.Area.Mesh.max)
head(LU.Area.Mesh.max)
LU.Area.Mesh.Dominant<-LU.Area.Mesh[LU.Area.Mesh$TriaHruAre %in% LU.Area.Mesh.max$TriaHruAre,]
LU.Area.Mesh.Dominant<-LU.Area.Mesh[LU.Area.Mesh$TriaHruAre %in% LU.Area.Mesh.max$TriaHruAre,]
LU.Area.Mesh.Dominant<-LU.Area.Mesh[LU.Area.Mesh.sum$TriaHruAre %in% LU.Area.Mesh.max$TriaHruAre,]
LU.Area.Mesh.Dominant<-LU.Area.Mesh.sum[LU.Area.Mesh.sum$TriaHruAre %in% LU.Area.Mesh.max$TriaHruAre,]
View(LU.Area.Mesh.Dominant)
## This is already a contingency table in array form.
DF <- as.data.frame(UCBAdmissions)
## Now 'DF' is a data frame with a grid of the factors and the counts
## in variable 'Freq'.
DF
UCBAdmissions
n <- 17; fac <- factor(rep_len(1:3, n), levels = 1:5)
table(fac)
tapply(1:n, fac, sum)
aggregate(state.x77, list(Region = state.region), mean)
head(state.x77)
head(LU.Area.Mesh.sum)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID+LU_CODE,data=LU.Area.Mesh.sum, FUN = max, simplify=T);
str(LU.Area.Mesh.max)
head(LU.Area.Mesh.max)
View(LU.Area.Mesh.max)
groups <- as.factor(rbinom(32, n = 5, prob = 0.4))
tapply(groups, groups, length) #- is almost the same as
table(groups)
tapply(warpbreaks$breaks, warpbreaks[,-1], sum)
tapply(warpbreaks$breaks, warpbreaks[, 3, drop = FALSE], sum)
warpbreaks
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = max, simplify=F);
View(LU.Area.Mesh.max)
m <- cbind(1, 1:7) # the '1' (= shorter vector) is recycled
m
cbind(LU.Area.Mesh.sum$Ele_ID,LU.Area.Mesh.sum$LU_CODE)
L
LU.Area.Mesh.sum<-aggregate(formula=TriaHruAre~Ele_ID+LU_CODE, data=Int_HRU_Mesh, FUN=sum, simplify=T) ;
head(LU.Area.Mesh.sum)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = summary, simplify=F);
head(LU.Area.Mesh.max)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = summary, simplify=T);
head(LU.Area.Mesh.max)
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = which.max(), simplify=T);
LU.Area.Mesh.max<-aggregate(formula=TriaHruAre~Ele_ID,data=LU.Area.Mesh.sum, FUN = which.max, simplify=T);
head(LU.Area.Mesh.max)
df <- read.table(header = TRUE, text = 'Gene   Value
A      12
A      10
B      3
B      5
B      6
C      1
D      3
D      4')
# aggregate
aggregate(df$Value, by = list(df$Gene), max)
aggregate(Value ~ Gene, data = df, max)
df <- read.table(header = TRUE, text = 'Gene   Value
A      12
A      10
B      3
B      5
B      6
C      1
D      3
D      4')
# aggregate
aggregate(df$Value, by = list(df$Gene), max)
aggregate(Value ~ Gene, data = df, max)
# tapply
tapply(df$Value, df$Gene, max)
# split + lapply
lapply(split(df, df$Gene), function(y) max(y$Value))
# plyr
require(plyr)
ddply(df, .(Gene), summarise, Value = max(Value))
# dplyr
require(dplyr)
df %>% group_by(Gene) %>% summarise(Value = max(Value))
library("plyr", lib.loc="C:/Felipe/Sotware&Coding/R_Library/library")
df <- read.table(header = TRUE, text = 'Gene   Value
A      12
A      10
B      3
B      5
B      6
C      1
D      3
D      4')
# aggregate
aggregate(df$Value, by = list(df$Gene), max)
aggregate(Value ~ Gene, data = df, max)
# tapply
tapply(df$Value, df$Gene, max)
# split + lapply
lapply(split(df, df$Gene), function(y) max(y$Value))
# plyr
require(plyr)
ddply(df, .(Gene), summarise, Value = max(Value))
# dplyr
require(dplyr)
df %>% group_by(Gene) %>% summarise(Value = max(Value))
split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID)
ID_LU<-split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID);
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),which.max);
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) which.max(x$TriaHruAre));
str(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) which.max(x$TriaHruAre)))
split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID)
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),max)
View(LU.Area.Mesh.sum)
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) max(x$TriaHruAre))
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) which.max(x$TriaHruAre))
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),"[" which.max(x$TriaHruAre))
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),"[", which.max(x$TriaHruAre))
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),2])
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
sapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
str(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),]))
xx<-lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
head(xx)
sapply(xx)
xx<-lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),],simplify=T)
xx<-lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
sapply(xx,"[",,)
sapply(xx,"[",1,)
head(xx)
sapply(xx,"[",)
sapply(xx,"[",,)
unlist(xx)
head(unlist(xx))
head(xx)
unsplit(xx)
unsplit(xx,LU.Area.Mesh.sum$Ele_ID)
str(xx)
str(xx)
unsplit(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
unsplit(xx,LU.Area.Mesh.sum$Ele_ID)
str(xx)
unsplit(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),]))
unsplit(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),]),..$Ele_ID)
unsplit(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),]),Ele_ID)
unsplit(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),]),xx$Ele_ID)
unsplit(lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),]),LU.Area.Mesh.sum$Ele_ID)
xx<-lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
unlist(xx)
str(unlist(xx))
str(unlist(xx, recursive = T))
unlist(xx, recursive = T)
l.ex <- list(a = list(1:5, LETTERS[1:5]), b = "Z", c = NA)
unlist(l.ex, recursive = FALSE)
unlist(l.ex, recursive = TRUE)
l.ex
sapply(xx,"[",,,simplify = "array")
xx
xxx<-data.frame(matrix(unlist(xx), nrow=883,byrow = T))
head(xxx)
xxx<-data.frame(matrix(unlist(xx), nrow=883,byrow = T),stringsAsFactors = F)
head(xxx)
data.frame(t(sapply(xxx,c)))
data.frame(t(sapply(xx,c)))
split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID)
xx<-lapply(split(LU.Area.Mesh.sum,LU.Area.Mesh.sum$Ele_ID),function(x) x[which.max(x$TriaHruAre),])
head(xx)
data.frame(t(sapply(xx,c)))
data.frame(t(sapply(xx,c)),stringsAsFactors = F)
head(xx)
sapply(xx,c)
data.frame(t(sapply(xx,c,USE.NAMES = F)),stringsAsFactors = F)
data.frame(t(sapply(xx,c,simplify = = F)),stringsAsFactors = F)
data.frame(t(sapply(xx,c,simplify  = F)),stringsAsFactors = F)
sapply(xx,c)
c(1,7:9)
c(1:5, 10.5, "next")
head(xx)
data.frame(Reduce(rbind, xx))
xxx<-data.frame(Reduce(rbind, xx))
View(xxx)
do.call(rbind.data.frame, XX)
do.call(rbind.data.frame, xx)
